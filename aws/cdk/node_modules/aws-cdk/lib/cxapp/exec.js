"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execProgram = execProgram;
exports.createAssembly = createAssembly;
const childProcess = require("child_process");
const os = require("os");
const path = require("path");
const util_1 = require("util");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const toolkit_lib_1 = require("@aws-cdk/toolkit-lib");
const fs = require("fs-extra");
const semver = require("semver");
const api_private_1 = require("../../lib/api-private");
const api_1 = require("../api");
const user_configuration_1 = require("../cli/user-configuration");
const version_1 = require("../cli/version");
const util_2 = require("../util");
/** Invokes the cloud executable and returns JSON output */
async function execProgram(aws, ioHelper, config) {
    const debugFn = (msg) => ioHelper.notify(api_private_1.IO.DEFAULT_ASSEMBLY_DEBUG.msg(msg));
    const env = await (0, api_1.prepareDefaultEnvironment)(aws, debugFn);
    const context = await (0, api_1.prepareContext)(config.settings, config.context.all, env, debugFn);
    const build = config.settings.get(['build']);
    if (build) {
        await exec(build);
    }
    const app = config.settings.get(['app']);
    if (!app) {
        throw new toolkit_lib_1.ToolkitError(`--app is required either in command-line, in ${user_configuration_1.PROJECT_CONFIG} or in ${user_configuration_1.USER_DEFAULTS}`);
    }
    // bypass "synth" if app points to a cloud assembly
    if (await fs.pathExists(app) && (await fs.stat(app)).isDirectory()) {
        await debugFn('--app points to a cloud assembly, so we bypass synth');
        // Acquire a read lock on this directory
        const lock = await new api_1.RWLock(app).acquireRead();
        return { assembly: createAssembly(app), lock };
    }
    const commandLine = await (0, api_1.guessExecutable)(app, debugFn);
    const outdir = config.settings.get(['output']);
    if (!outdir) {
        throw new toolkit_lib_1.ToolkitError('unexpected: --output is required');
    }
    if (typeof outdir !== 'string') {
        throw new toolkit_lib_1.ToolkitError(`--output takes a string, got ${JSON.stringify(outdir)}`);
    }
    try {
        await fs.mkdirp(outdir);
    }
    catch (error) {
        throw new toolkit_lib_1.ToolkitError(`Could not create output directory ${outdir} (${error.message})`);
    }
    await debugFn(`outdir: ${outdir}`);
    env[cxapi.OUTDIR_ENV] = outdir;
    // Acquire a lock on the output directory
    const writerLock = await new api_1.RWLock(outdir).acquireWrite();
    try {
        // Send version information
        env[cxapi.CLI_ASM_VERSION_ENV] = cxschema.Manifest.version();
        env[cxapi.CLI_VERSION_ENV] = (0, version_1.versionNumber)();
        await debugFn((0, util_1.format)('env:', env));
        const envVariableSizeLimit = os.platform() === 'win32' ? 32760 : 131072;
        const [smallContext, overflow] = (0, util_2.splitBySize)(context, (0, api_1.spaceAvailableForContext)(env, envVariableSizeLimit));
        // Store the safe part in the environment variable
        env[cxapi.CONTEXT_ENV] = JSON.stringify(smallContext);
        // If there was any overflow, write it to a temporary file
        let contextOverflowLocation;
        if (Object.keys(overflow ?? {}).length > 0) {
            const contextDir = await fs.mkdtemp(path.join(os.tmpdir(), 'cdk-context'));
            contextOverflowLocation = path.join(contextDir, 'context-overflow.json');
            fs.writeJSONSync(contextOverflowLocation, overflow);
            env[cxapi.CONTEXT_OVERFLOW_LOCATION_ENV] = contextOverflowLocation;
        }
        await exec(commandLine.join(' '));
        const assembly = createAssembly(outdir);
        await contextOverflowCleanup(contextOverflowLocation, assembly, ioHelper);
        return { assembly, lock: await writerLock.convertToReaderLock() };
    }
    catch (e) {
        await writerLock.release();
        throw e;
    }
    async function exec(commandAndArgs) {
        try {
            await new Promise((ok, fail) => {
                // We use a slightly lower-level interface to:
                //
                // - Pass arguments in an array instead of a string, to get around a
                //   number of quoting issues introduced by the intermediate shell layer
                //   (which would be different between Linux and Windows).
                //
                // - Inherit stderr from controlling terminal. We don't use the captured value
                //   anyway, and if the subprocess is printing to it for debugging purposes the
                //   user gets to see it sooner. Plus, capturing doesn't interact nicely with some
                //   processes like Maven.
                const proc = childProcess.spawn(commandAndArgs, {
                    stdio: ['ignore', 'inherit', 'inherit'],
                    detached: false,
                    shell: true,
                    env: {
                        ...process.env,
                        ...env,
                    },
                });
                proc.on('error', fail);
                proc.on('exit', code => {
                    if (code === 0) {
                        return ok();
                    }
                    else {
                        return fail(new toolkit_lib_1.ToolkitError(`${commandAndArgs}: Subprocess exited with error ${code}`));
                    }
                });
            });
        }
        catch (e) {
            await debugFn(`failed command: ${commandAndArgs}`);
            throw e;
        }
    }
}
/**
 * Creates an assembly with error handling
 */
function createAssembly(appDir) {
    try {
        return new cxapi.CloudAssembly(appDir, {
            // We sort as we deploy
            topoSort: false,
        });
    }
    catch (error) {
        if (error.message.includes(cxschema.VERSION_MISMATCH)) {
            // this means the CLI version is too old.
            // we instruct the user to upgrade.
            throw new toolkit_lib_1.ToolkitError(`This CDK CLI is not compatible with the CDK library used by your application. Please upgrade the CLI to the latest version.\n(${error.message})`);
        }
        throw error;
    }
}
async function contextOverflowCleanup(location, assembly, ioHelper) {
    if (location) {
        fs.removeSync(path.dirname(location));
        const tree = await (0, api_1.loadTree)(assembly, (msg) => ioHelper.notify(api_private_1.IO.DEFAULT_ASSEMBLY_TRACE.msg(msg)));
        const frameworkDoesNotSupportContextOverflow = (0, api_1.some)(tree, node => {
            const fqn = node.constructInfo?.fqn;
            const version = node.constructInfo?.version;
            return (fqn === 'aws-cdk-lib.App' && version != null && semver.lte(version, '2.38.0'))
                || fqn === '@aws-cdk/core.App'; // v1
        });
        // We're dealing with an old version of the framework here. It is unaware of the temporary
        // file, which means that it will ignore the context overflow.
        if (frameworkDoesNotSupportContextOverflow) {
            await ioHelper.notify(api_private_1.IO.DEFAULT_ASSEMBLY_WARN.msg('Part of the context could not be sent to the application. Please update the AWS CDK library to the latest version.'));
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhlYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImV4ZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUF1QkEsa0NBc0hDO0FBS0Qsd0NBY0M7QUFoS0QsOENBQThDO0FBQzlDLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsK0JBQThCO0FBQzlCLDJEQUEyRDtBQUMzRCx5Q0FBeUM7QUFDekMsc0RBQW9EO0FBQ3BELCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakMsdURBQTBEO0FBRTFELGdDQUFzSTtBQUV0SSxrRUFBMEU7QUFDMUUsNENBQStDO0FBQy9DLGtDQUFzQztBQU90QywyREFBMkQ7QUFDcEQsS0FBSyxVQUFVLFdBQVcsQ0FBQyxHQUFnQixFQUFFLFFBQWtCLEVBQUUsTUFBcUI7SUFDM0YsTUFBTSxPQUFPLEdBQUcsQ0FBQyxHQUFXLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsZ0JBQUUsQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNyRixNQUFNLEdBQUcsR0FBRyxNQUFNLElBQUEsK0JBQXlCLEVBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzFELE1BQU0sT0FBTyxHQUFHLE1BQU0sSUFBQSxvQkFBYyxFQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRXhGLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUM3QyxJQUFJLEtBQUssRUFBRSxDQUFDO1FBQ1YsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDcEIsQ0FBQztJQUVELE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUN6QyxJ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QyxvSEFBb0gsQ0FBQyxDQUFDLENBQUM7UUFDNUssQ0FBQztJQUNILENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY2hpbGRQcm9jZXNzIGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0ICogYXMgY3hzY2hlbWEgZnJvbSAnQGF3cy1jZGsvY2xvdWQtYXNzZW1ibHktc2NoZW1hJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICdAYXdzLWNkay90b29sa2l0LWxpYic7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyBzZW12ZXIgZnJvbSAnc2VtdmVyJztcbmltcG9ydCB7IElPLCB0eXBlIElvSGVscGVyIH0gZnJvbSAnLi4vLi4vbGliL2FwaS1wcml2YXRlJztcbmltcG9ydCB0eXBlIHsgU2RrUHJvdmlkZXIsIElSZWFkTG9jayB9IGZyb20gJy4uL2FwaSc7XG5pbXBvcnQgeyBSV0xvY2ssIGd1ZXNzRXhlY3V0YWJsZSwgbG9hZFRyZWUsIHByZXBhcmVDb250ZXh0LCBwcmVwYXJlRGVmYXVsdEVudmlyb25tZW50LCBzb21lLCBzcGFjZUF2YWlsYWJsZUZvckNvbnRleHQgfSBmcm9tICcuLi9hcGknO1xuaW1wb3J0IHR5cGUgeyBDb25maWd1cmF0aW9uIH0gZnJvbSAnLi4vY2xpL3VzZXItY29uZmlndXJhdGlvbic7XG5pbXBvcnQgeyBQUk9KRUNUX0NPTkZJRywgVVNFUl9ERUZBVUxUUyB9IGZyb20gJy4uL2NsaS91c2VyLWNvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHsgdmVyc2lvbk51bWJlciB9IGZyb20gJy4uL2NsaS92ZXJzaW9uJztcbmltcG9ydCB7IHNwbGl0QnlTaXplIH0gZnJvbSAnLi4vdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhlY1Byb2dyYW1SZXN1bHQge1xuICByZWFkb25seSBhc3NlbWJseTogY3hhcGkuQ2xvdWRBc3NlbWJseTtcbiAgcmVhZG9ubHkgbG9jazogSVJlYWRMb2NrO1xufVxuXG4vKiogSW52b2tlcyB0aGUgY2xvdWQgZXhlY3V0YWJsZSBhbmQgcmV0dXJucyBKU09OIG91dHB1dCAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4ZWNQcm9ncmFtKGF3czogU2RrUHJvdmlkZXIsIGlvSGVscGVyOiBJb0hlbHBlciwgY29uZmlnOiBDb25maWd1cmF0aW9uKTogUHJvbWlzZTxFeGVjUHJvZ3JhbVJlc3VsdD4ge1xuICBjb25zdCBkZWJ1Z0ZuID0gKG1zZzogc3RyaW5nKSA9PiBpb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9BU1NFTUJMWV9ERUJVRy5tc2cobXNnKSk7XG4gIGNvbnN0IGVudiA9IGF3YWl0IHByZXBhcmVEZWZhdWx0RW52aXJvbm1lbnQoYXdzLCBkZWJ1Z0ZuKTtcbiAgY29uc3QgY29udGV4dCA9IGF3YWl0IHByZXBhcmVDb250ZXh0KGNvbmZpZy5zZXR0aW5ncywgY29uZmlnLmNvbnRleHQuYWxsLCBlbnYsIGRlYnVnRm4pO1xuXG4gIGNvbnN0IGJ1aWxkID0gY29uZmlnLnNldHRpbmdzLmdldChbJ2J1aWxkJ10pO1xuICBpZiAoYnVpbGQpIHtcbiAgICBhd2FpdCBleGVjKGJ1aWxkKTtcbiAgfVxuXG4gIGNvbnN0IGFwcCA9IGNvbmZpZy5zZXR0aW5ncy5nZXQoWydhcHAnXSk7XG4gIGlmICghYXBwKSB7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgLS1hcHAgaXMgcmVxdWlyZWQgZWl0aGVyIGluIGNvbW1hbmQtbGluZSwgaW4gJHtQUk9KRUNUX0NPTkZJR30gb3IgaW4gJHtVU0VSX0RFRkFVTFRTfWApO1xuICB9XG5cbiAgLy8gYnlwYXNzIFwic3ludGhcIiBpZiBhcHAgcG9pbnRzIHRvIGEgY2xvdWQgYXNzZW1ibHlcbiAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMoYXBwKSAmJiAoYXdhaXQgZnMuc3RhdChhcHApKS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgYXdhaXQgZGVidWdGbignLS1hcHAgcG9pbnRzIHRvIGEgY2xvdWQgYXNzZW1ibHksIHNvIHdlIGJ5cGFzcyBzeW50aCcpO1xuXG4gICAgLy8gQWNxdWlyZSBhIHJlYWQgbG9jayBvbiB0aGlzIGRpcmVjdG9yeVxuICAgIGNvbnN0IGxvY2sgPSBhd2FpdCBuZXcgUldMb2NrKGFwcCkuYWNxdWlyZVJlYWQoKTtcblxuICAgIHJldHVybiB7IGFzc2VtYmx5OiBjcmVhdGVBc3NlbWJseShhcHApLCBsb2NrIH07XG4gIH1cblxuICBjb25zdCBjb21tYW5kTGluZSA9IGF3YWl0IGd1ZXNzRXhlY3V0YWJsZShhcHAsIGRlYnVnRm4pO1xuXG4gIGNvbnN0IG91dGRpciA9IGNvbmZpZy5zZXR0aW5ncy5nZXQoWydvdXRwdXQnXSk7XG4gIGlmICghb3V0ZGlyKSB7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcigndW5leHBlY3RlZDogLS1vdXRwdXQgaXMgcmVxdWlyZWQnKTtcbiAgfVxuICBpZiAodHlwZW9mIG91dGRpciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGAtLW91dHB1dCB0YWtlcyBhIHN0cmluZywgZ290ICR7SlNPTi5zdHJpbmdpZnkob3V0ZGlyKX1gKTtcbiAgfVxuICB0cnkge1xuICAgIGF3YWl0IGZzLm1rZGlycChvdXRkaXIpO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgQ291bGQgbm90IGNyZWF0ZSBvdXRwdXQgZGlyZWN0b3J5ICR7b3V0ZGlyfSAoJHtlcnJvci5tZXNzYWdlfSlgKTtcbiAgfVxuXG4gIGF3YWl0IGRlYnVnRm4oYG91dGRpcjogJHtvdXRkaXJ9YCk7XG4gIGVudltjeGFwaS5PVVRESVJfRU5WXSA9IG91dGRpcjtcblxuICAvLyBBY3F1aXJlIGEgbG9jayBvbiB0aGUgb3V0cHV0IGRpcmVjdG9yeVxuICBjb25zdCB3cml0ZXJMb2NrID0gYXdhaXQgbmV3IFJXTG9jayhvdXRkaXIpLmFjcXVpcmVXcml0ZSgpO1xuXG4gIHRyeSB7XG4gICAgLy8gU2VuZCB2ZXJzaW9uIGluZm9ybWF0aW9uXG4gICAgZW52W2N4YXBpLkNMSV9BU01fVkVSU0lPTl9FTlZdID0gY3hzY2hlbWEuTWFuaWZlc3QudmVyc2lvbigpO1xuICAgIGVudltjeGFwaS5DTElfVkVSU0lPTl9FTlZdID0gdmVyc2lvbk51bWJlcigpO1xuXG4gICAgYXdhaXQgZGVidWdGbihmb3JtYXQoJ2VudjonLCBlbnYpKTtcblxuICAgIGNvbnN0IGVudlZhcmlhYmxlU2l6ZUxpbWl0ID0gb3MucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJyA/IDMyNzYwIDogMTMxMDcyO1xuICAgIGNvbnN0IFtzbWFsbENvbnRleHQsIG92ZXJmbG93XSA9IHNwbGl0QnlTaXplKGNvbnRleHQsIHNwYWNlQXZhaWxhYmxlRm9yQ29udGV4dChlbnYsIGVudlZhcmlhYmxlU2l6ZUxpbWl0KSk7XG5cbiAgICAvLyBTdG9yZSB0aGUgc2FmZSBwYXJ0IGluIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICAgIGVudltjeGFwaS5DT05URVhUX0VOVl0gPSBKU09OLnN0cmluZ2lmeShzbWFsbENvbnRleHQpO1xuXG4gICAgLy8gSWYgdGhlcmUgd2FzIGFueSBvdmVyZmxvdywgd3JpdGUgaXQgdG8gYSB0ZW1wb3JhcnkgZmlsZVxuICAgIGxldCBjb250ZXh0T3ZlcmZsb3dMb2NhdGlvbjtcbiAgICBpZiAoT2JqZWN0LmtleXMob3ZlcmZsb3cgPz8ge30pLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNvbnRleHREaXIgPSBhd2FpdCBmcy5ta2R0ZW1wKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ2Nkay1jb250ZXh0JykpO1xuICAgICAgY29udGV4dE92ZXJmbG93TG9jYXRpb24gPSBwYXRoLmpvaW4oY29udGV4dERpciwgJ2NvbnRleHQtb3ZlcmZsb3cuanNvbicpO1xuICAgICAgZnMud3JpdGVKU09OU3luYyhjb250ZXh0T3ZlcmZsb3dMb2NhdGlvbiwgb3ZlcmZsb3cpO1xuICAgICAgZW52W2N4YXBpLkNPTlRFWFRfT1ZFUkZMT1dfTE9DQVRJT05fRU5WXSA9IGNvbnRleHRPdmVyZmxvd0xvY2F0aW9uO1xuICAgIH1cblxuICAgIGF3YWl0IGV4ZWMoY29tbWFuZExpbmUuam9pbignICcpKTtcblxuICAgIGNvbnN0IGFzc2VtYmx5ID0gY3JlYXRlQXNzZW1ibHkob3V0ZGlyKTtcblxuICAgIGF3YWl0IGNvbnRleHRPdmVyZmxvd0NsZWFudXAoY29udGV4dE92ZXJmbG93TG9jYXRpb24sIGFzc2VtYmx5LCBpb0hlbHBlcik7XG5cbiAgICByZXR1cm4geyBhc3NlbWJseSwgbG9jazogYXdhaXQgd3JpdGVyTG9jay5jb252ZXJ0VG9SZWFkZXJMb2NrKCkgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGF3YWl0IHdyaXRlckxvY2sucmVsZWFzZSgpO1xuICAgIHRocm93IGU7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBleGVjKGNvbW1hbmRBbmRBcmdzOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKG9rLCBmYWlsKSA9PiB7XG4gICAgICAgIC8vIFdlIHVzZSBhIHNsaWdodGx5IGxvd2VyLWxldmVsIGludGVyZmFjZSB0bzpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gLSBQYXNzIGFyZ3VtZW50cyBpbiBhbiBhcnJheSBpbnN0ZWFkIG9mIGEgc3RyaW5nLCB0byBnZXQgYXJvdW5kIGFcbiAgICAgICAgLy8gICBudW1iZXIgb2YgcXVvdGluZyBpc3N1ZXMgaW50cm9kdWNlZCBieSB0aGUgaW50ZXJtZWRpYXRlIHNoZWxsIGxheWVyXG4gICAgICAgIC8vICAgKHdoaWNoIHdvdWxkIGJlIGRpZmZlcmVudCBiZXR3ZWVuIExpbnV4IGFuZCBXaW5kb3dzKS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gLSBJbmhlcml0IHN0ZGVyciBmcm9tIGNvbnRyb2xsaW5nIHRlcm1pbmFsLiBXZSBkb24ndCB1c2UgdGhlIGNhcHR1cmVkIHZhbHVlXG4gICAgICAgIC8vICAgYW55d2F5LCBhbmQgaWYgdGhlIHN1YnByb2Nlc3MgaXMgcHJpbnRpbmcgdG8gaXQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcyB0aGVcbiAgICAgICAgLy8gICB1c2VyIGdldHMgdG8gc2VlIGl0IHNvb25lci4gUGx1cywgY2FwdHVyaW5nIGRvZXNuJ3QgaW50ZXJhY3QgbmljZWx5IHdpdGggc29tZVxuICAgICAgICAvLyAgIHByb2Nlc3NlcyBsaWtlIE1hdmVuLlxuICAgICAgICBjb25zdCBwcm9jID0gY2hpbGRQcm9jZXNzLnNwYXduKGNvbW1hbmRBbmRBcmdzLCB7XG4gICAgICAgICAgc3RkaW86IFsnaWdub3JlJywgJ2luaGVyaXQnLCAnaW5oZXJpdCddLFxuICAgICAgICAgIGRldGFjaGVkOiBmYWxzZSxcbiAgICAgICAgICBzaGVsbDogdHJ1ZSxcbiAgICAgICAgICBlbnY6IHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3MuZW52LFxuICAgICAgICAgICAgLi4uZW52LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb2Mub24oJ2Vycm9yJywgZmFpbCk7XG5cbiAgICAgICAgcHJvYy5vbignZXhpdCcsIGNvZGUgPT4ge1xuICAgICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gb2soKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwobmV3IFRvb2xraXRFcnJvcihgJHtjb21tYW5kQW5kQXJnc306IFN1YnByb2Nlc3MgZXhpdGVkIHdpdGggZXJyb3IgJHtjb2RlfWApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBhd2FpdCBkZWJ1Z0ZuKGBmYWlsZWQgY29tbWFuZDogJHtjb21tYW5kQW5kQXJnc31gKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhc3NlbWJseSB3aXRoIGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBc3NlbWJseShhcHBEaXI6IHN0cmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgY3hhcGkuQ2xvdWRBc3NlbWJseShhcHBEaXIsIHtcbiAgICAgIC8vIFdlIHNvcnQgYXMgd2UgZGVwbG95XG4gICAgICB0b3BvU29ydDogZmFsc2UsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhjeHNjaGVtYS5WRVJTSU9OX01JU01BVENIKSkge1xuICAgICAgLy8gdGhpcyBtZWFucyB0aGUgQ0xJIHZlcnNpb24gaXMgdG9vIG9sZC5cbiAgICAgIC8vIHdlIGluc3RydWN0IHRoZSB1c2VyIHRvIHVwZ3JhZGUuXG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBUaGlzIENESyBDTEkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgQ0RLIGxpYnJhcnkgdXNlZCBieSB5b3VyIGFwcGxpY2F0aW9uLiBQbGVhc2UgdXBncmFkZSB0aGUgQ0xJIHRvIHRoZSBsYXRlc3QgdmVyc2lvbi5cXG4oJHtlcnJvci5tZXNzYWdlfSlgKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY29udGV4dE92ZXJmbG93Q2xlYW51cChcbiAgbG9jYXRpb246IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgYXNzZW1ibHk6IGN4YXBpLkNsb3VkQXNzZW1ibHksXG4gIGlvSGVscGVyOiBJb0hlbHBlcixcbikge1xuICBpZiAobG9jYXRpb24pIHtcbiAgICBmcy5yZW1vdmVTeW5jKHBhdGguZGlybmFtZShsb2NhdGlvbikpO1xuXG4gICAgY29uc3QgdHJlZSA9IGF3YWl0IGxvYWRUcmVlKGFzc2VtYmx5LCAobXNnOiBzdHJpbmcpID0+IGlvSGVscGVyLm5vdGlmeShJTy5ERUZBVUxUX0FTU0VNQkxZX1RSQUNFLm1zZyhtc2cpKSk7XG4gICAgY29uc3QgZnJhbWV3b3JrRG9lc05vdFN1cHBvcnRDb250ZXh0T3ZlcmZsb3cgPSBzb21lKHRyZWUsIG5vZGUgPT4ge1xuICAgICAgY29uc3QgZnFuID0gbm9kZS5jb25zdHJ1Y3RJbmZvPy5mcW47XG4gICAgICBjb25zdCB2ZXJzaW9uID0gbm9kZS5jb25zdHJ1Y3RJbmZvPy52ZXJzaW9uO1xuICAgICAgcmV0dXJuIChmcW4gPT09ICdhd3MtY2RrLWxpYi5BcHAnICYmIHZlcnNpb24gIT0gbnVsbCAmJiBzZW12ZXIubHRlKHZlcnNpb24sICcyLjM4LjAnKSlcbiAgICAgICAgfHwgZnFuID09PSAnQGF3cy1jZGsvY29yZS5BcHAnOyAvLyB2MVxuICAgIH0pO1xuXG4gICAgLy8gV2UncmUgZGVhbGluZyB3aXRoIGFuIG9sZCB2ZXJzaW9uIG9mIHRoZSBmcmFtZXdvcmsgaGVyZS4gSXQgaXMgdW5hd2FyZSBvZiB0aGUgdGVtcG9yYXJ5XG4gICAgLy8gZmlsZSwgd2hpY2ggbWVhbnMgdGhhdCBpdCB3aWxsIGlnbm9yZSB0aGUgY29udGV4dCBvdmVyZmxvdy5cbiAgICBpZiAoZnJhbWV3b3JrRG9lc05vdFN1cHBvcnRDb250ZXh0T3ZlcmZsb3cpIHtcbiAgICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShJTy5ERUZBVUxUX0FTU0VNQkxZX1dBUk4ubXNnKCdQYXJ0IG9mIHRoZSBjb250ZXh0IGNvdWxkIG5vdCBiZSBzZW50IHRvIHRoZSBhcHBsaWNhdGlvbi4gUGxlYXNlIHVwZGF0ZSB0aGUgQVdTIENESyBsaWJyYXJ5IHRvIHRoZSBsYXRlc3QgdmVyc2lvbi4nKSk7XG4gICAgfVxuICB9XG59XG4iXX0=